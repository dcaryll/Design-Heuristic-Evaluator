import jsPDF from 'jspdf';
import { DesignAnalysis, ComparisonAnalysis, HEURISTIC_LABELS, UploadedImage } from '../types/analysis';

export interface PDFOptions {
  title?: string;
  subtitle?: string;
  includeImages?: boolean;
  images?: UploadedImage[];
}

const RED_HAT_RED = '#ee0000';
const RED_HAT_BLUE = '#0066cc';
const RED_HAT_DARK = '#151515';
const RED_HAT_GRAY = '#6a6e73';

// Convert image URL to base64 for PDF inclusion
const imageToBase64 = (url: string): Promise<string> => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        reject(new Error('Could not get canvas context'));
        return;
      }
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      try {
        const base64 = canvas.toDataURL('image/jpeg', 0.8);
        resolve(base64);
      } catch (error) {
        reject(error);
      }
    };
    img.onerror = () => reject(new Error('Failed to load image'));
    img.src = url;
  });
};

// Add thumbnail image to PDF
const addThumbnailToPDF = async (pdf: jsPDF, imageUrl: string, x: number, y: number, maxWidth: number, maxHeight: number): Promise<number> => {
  try {
    const base64Image = await imageToBase64(imageUrl);
    
    // Get image dimensions
    const img = new Image();
    await new Promise((resolve) => {
      img.onload = resolve;
      img.src = base64Image;
    });
    
    // Calculate scaling to fit within maxWidth x maxHeight
    const aspectRatio = img.width / img.height;
    let width = maxWidth;
    let height = maxWidth / aspectRatio;
    
    if (height > maxHeight) {
      height = maxHeight;
      width = maxHeight * aspectRatio;
    }
    
    // Add image to PDF
    pdf.addImage(base64Image, 'JPEG', x, y, width, height);
    
    return y + height + 10; // Return new Y position after image
  } catch (error) {
    console.warn('Could not add image to PDF:', error);
    return y; // Return original Y position if image fails
  }
};

export const generateSingleAnalysisPDF = async (
  analysis: DesignAnalysis,
  options: PDFOptions = {}
): Promise<Blob> => {
  const pdf = new jsPDF('p', 'mm', 'a4');
  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();
  let yPosition = 20;

  // Header
  pdf.setFontSize(24);
  pdf.setTextColor(RED_HAT_RED);
  pdf.text(options.title || 'Design Heuristic Analysis', 20, yPosition);
  yPosition += 15;

  pdf.setFontSize(12);
  pdf.setTextColor(RED_HAT_GRAY);
  pdf.text(options.subtitle || 'Generated by Design Evaluator', 20, yPosition);
  yPosition += 20;

  // Add thumbnail image if provided
  if (options.images && options.images.length > 0) {
    pdf.setFontSize(14);
    pdf.setTextColor(RED_HAT_DARK);
    pdf.text('Analyzed Design:', 20, yPosition);
    yPosition += 10;
    
    yPosition = await addThumbnailToPDF(pdf, options.images[0].preview, 20, yPosition, 80, 60);
    yPosition += 10;
  }

  // Overall Score
  pdf.setFontSize(18);
  pdf.setTextColor(RED_HAT_DARK);
  pdf.text('Overall Score', 20, yPosition);
  yPosition += 10;

  pdf.setFontSize(36);
  const scoreColor = analysis.overall_score >= 80 ? '#3e8635' : 
                    analysis.overall_score >= 60 ? '#f0ab00' : '#c9190b';
  pdf.setTextColor(scoreColor);
  pdf.text(`${analysis.overall_score}/100`, 20, yPosition);
  yPosition += 25;

  // Heuristic Breakdown
  pdf.setFontSize(16);
  pdf.setTextColor(RED_HAT_DARK);
  pdf.text('Heuristic Breakdown', 20, yPosition);
  yPosition += 10;

  // Create heuristic scores table
  Object.entries(analysis.heuristic_scores).forEach(([key, score]) => {
    if (yPosition > pageHeight - 30) {
      pdf.addPage();
      yPosition = 20;
    }

    const label = HEURISTIC_LABELS[key as keyof typeof HEURISTIC_LABELS] || key;
    const reasoning = analysis.heuristic_reasoning?.[key] || 'No detailed analysis available.';

    // Heuristic name and score
    pdf.setFontSize(12);
    pdf.setTextColor(RED_HAT_DARK);
    pdf.text(label, 20, yPosition);
    
    pdf.setFontSize(14);
    const heuristicScoreColor = score >= 8 ? '#3e8635' : score >= 6 ? '#f0ab00' : '#c9190b';
    pdf.setTextColor(heuristicScoreColor);
    pdf.text(`${score}/10`, pageWidth - 30, yPosition);
    yPosition += 8;

    // Reasoning (wrapped text)
    pdf.setFontSize(10);
    pdf.setTextColor(RED_HAT_GRAY);
    const splitReasoning = pdf.splitTextToSize(reasoning, pageWidth - 40);
    pdf.text(splitReasoning, 20, yPosition);
    yPosition += splitReasoning.length * 4 + 8;
  });

  // Strengths
  if (analysis.strengths && analysis.strengths.length > 0) {
    if (yPosition > pageHeight - 50) {
      pdf.addPage();
      yPosition = 20;
    }

    pdf.setFontSize(16);
    pdf.setTextColor(RED_HAT_DARK);
    pdf.text('Strengths', 20, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setTextColor(RED_HAT_DARK);
    analysis.strengths.forEach((strength) => {
      if (yPosition > pageHeight - 10) {
        pdf.addPage();
        yPosition = 20;
      }
      const wrappedText = pdf.splitTextToSize(`• ${strength}`, pageWidth - 40);
      pdf.text(wrappedText, 20, yPosition);
      yPosition += wrappedText.length * 4 + 3;
    });
    yPosition += 10;
  }

  // Areas for Improvement
  if (analysis.areas_for_improvement && analysis.areas_for_improvement.length > 0) {
    if (yPosition > pageHeight - 50) {
      pdf.addPage();
      yPosition = 20;
    }

    pdf.setFontSize(16);
    pdf.setTextColor(RED_HAT_DARK);
    pdf.text('Areas for improvement', 20, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setTextColor(RED_HAT_DARK);
    analysis.areas_for_improvement.forEach((improvement) => {
      if (yPosition > pageHeight - 10) {
        pdf.addPage();
        yPosition = 20;
      }
      const wrappedText = pdf.splitTextToSize(`• ${improvement}`, pageWidth - 40);
      pdf.text(wrappedText, 20, yPosition);
      yPosition += wrappedText.length * 4 + 3;
    });
    yPosition += 10;
  }

  // Recommendations
  if (analysis.recommendations && analysis.recommendations.length > 0) {
    if (yPosition > pageHeight - 50) {
      pdf.addPage();
      yPosition = 20;
    }

    pdf.setFontSize(16);
    pdf.setTextColor(RED_HAT_DARK);
    pdf.text('Actionable Recommendations', 20, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setTextColor(RED_HAT_DARK);
    analysis.recommendations.forEach((recommendation) => {
      if (yPosition > pageHeight - 10) {
        pdf.addPage();
        yPosition = 20;
      }
      const wrappedText = pdf.splitTextToSize(`• ${recommendation}`, pageWidth - 40);
      pdf.text(wrappedText, 20, yPosition);
      yPosition += wrappedText.length * 4 + 3;
    });
  }

  // Footer
  const totalPages = (pdf as any).internal.getNumberOfPages();
  pdf.setPage(totalPages);
  pdf.setFontSize(8);
  pdf.setTextColor(RED_HAT_GRAY);
  const timestamp = new Date().toLocaleDateString();
  pdf.text(`Generated on ${timestamp} by Design Evaluator`, 20, pageHeight - 10);
  pdf.text('Based on Jakob Nielsen\'s 10 Usability Heuristics and Modern UX Principles', 20, pageHeight - 5);

  return pdf.output('blob');
};

export const generateComparisonPDF = async (
  comparison: ComparisonAnalysis,
  options: PDFOptions = {}
): Promise<Blob> => {
  const pdf = new jsPDF('p', 'mm', 'a4');
  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();
  let yPosition = 20;

  // Header
  pdf.setFontSize(24);
  pdf.setTextColor(RED_HAT_RED);
  pdf.text(options.title || 'Design Comparison Analysis', 20, yPosition);
  yPosition += 15;

  pdf.setFontSize(12);
  pdf.setTextColor(RED_HAT_GRAY);
  pdf.text(options.subtitle || 'Generated by Design Evaluator', 20, yPosition);
  yPosition += 20;

  // Add thumbnail images if provided
  if (options.images && options.images.length >= 2) {
    pdf.setFontSize(14);
    pdf.setTextColor(RED_HAT_DARK);
    pdf.text('Design A', 20, yPosition);
    pdf.text('Design B', pageWidth / 2 + 10, yPosition);
    yPosition += 10;
    
    // Add both images side by side
    const imageWidth = (pageWidth - 60) / 2; // Split width between two images
    const imageHeight = 45; // Fixed height for consistency
    
    const imageAPromise = addThumbnailToPDF(pdf, options.images[0].preview, 20, yPosition, imageWidth, imageHeight);
    const imageBPromise = addThumbnailToPDF(pdf, options.images[1].preview, pageWidth / 2 + 10, yPosition, imageWidth, imageHeight);
    
    // Wait for both images to load and get the maximum Y position
    const [newYA, newYB] = await Promise.all([imageAPromise, imageBPromise]);
    yPosition = Math.max(newYA, newYB) + 10;
  }

  // Winner
  pdf.setFontSize(18);
  pdf.setTextColor(RED_HAT_DARK);
  const winnerText = comparison.winner === 'design_a' ? 'Design A Wins' :
                    comparison.winner === 'design_b' ? 'Design B Wins' : 'It\'s a Tie';
  pdf.text(`Result: ${winnerText}`, 20, yPosition);
  yPosition += 15;

  pdf.setFontSize(12);
  pdf.setTextColor(RED_HAT_GRAY);
  const reasoningText = pdf.splitTextToSize(comparison.reasoning, pageWidth - 40);
  pdf.text(reasoningText, 20, yPosition);
  yPosition += reasoningText.length * 5 + 15;

  // Design A Analysis
  if (comparison.design_a_analysis) {
    if (yPosition > pageHeight - 50) {
      pdf.addPage();
      yPosition = 20;
    }

    pdf.setFontSize(16);
    pdf.setTextColor(RED_HAT_DARK);
    pdf.text('Design A Analysis', 20, yPosition);
    yPosition += 10;

    pdf.setFontSize(14);
    pdf.setTextColor(RED_HAT_BLUE);
    pdf.text(`Score: ${comparison.design_a_score}/100`, 20, yPosition);
    yPosition += 15;

    // Add heuristic breakdown for Design A (abbreviated)
    Object.entries(comparison.design_a_analysis.heuristic_scores).slice(0, 5).forEach(([key, score]) => {
      const label = HEURISTIC_LABELS[key as keyof typeof HEURISTIC_LABELS] || key;
      pdf.setFontSize(10);
      pdf.setTextColor(RED_HAT_DARK);
      pdf.text(`${label}: ${score}/10`, 20, yPosition);
      yPosition += 5;
    });
    yPosition += 10;
  }

  // Design B Analysis
  if (comparison.design_b_analysis) {
    if (yPosition > pageHeight - 50) {
      pdf.addPage();
      yPosition = 20;
    }

    pdf.setFontSize(16);
    pdf.setTextColor(RED_HAT_DARK);
    pdf.text('Design B Analysis', 20, yPosition);
    yPosition += 10;

    pdf.setFontSize(14);
    pdf.setTextColor(RED_HAT_BLUE);
    pdf.text(`Score: ${comparison.design_b_score}/100`, 20, yPosition);
    yPosition += 15;

    // Add heuristic breakdown for Design B (abbreviated)
    Object.entries(comparison.design_b_analysis.heuristic_scores).slice(0, 5).forEach(([key, score]) => {
      const label = HEURISTIC_LABELS[key as keyof typeof HEURISTIC_LABELS] || key;
      pdf.setFontSize(10);
      pdf.setTextColor(RED_HAT_DARK);
      pdf.text(`${label}: ${score}/10`, 20, yPosition);
      yPosition += 5;
    });
    yPosition += 10;
  }

  // Recommendations
  if (comparison.recommendations && comparison.recommendations.length > 0) {
    if (yPosition > pageHeight - 50) {
      pdf.addPage();
      yPosition = 20;
    }

    pdf.setFontSize(16);
    pdf.setTextColor(RED_HAT_DARK);
    pdf.text('Recommendations', 20, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setTextColor(RED_HAT_DARK);
    comparison.recommendations.forEach((recommendation) => {
      if (yPosition > pageHeight - 10) {
        pdf.addPage();
        yPosition = 20;
      }
      const wrappedText = pdf.splitTextToSize(`• ${recommendation}`, pageWidth - 40);
      pdf.text(wrappedText, 20, yPosition);
      yPosition += wrappedText.length * 4 + 3;
    });
  }

  // Footer
  const totalPages = (pdf as any).internal.getNumberOfPages();
  pdf.setPage(totalPages);
  pdf.setFontSize(8);
  pdf.setTextColor(RED_HAT_GRAY);
  const timestamp = new Date().toLocaleDateString();
  pdf.text(`Generated on ${timestamp} by Design Evaluator`, 20, pageHeight - 10);
  pdf.text('Based on Jakob Nielsen\'s 10 Usability Heuristics and Modern UX Principles', 20, pageHeight - 5);

  return pdf.output('blob');
};

export const downloadPDF = (blob: Blob, filename: string) => {
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
};

export const sharePDF = async (blob: Blob, filename: string, title?: string) => {
  if (navigator.share && navigator.canShare) {
    try {
      const file = new File([blob], filename, { type: 'application/pdf' });
      if (navigator.canShare({ files: [file] })) {
        await navigator.share({
          title: title || 'Design Analysis Results',
          text: 'Check out this design heuristic analysis!',
          files: [file]
        });
        return true;
      }
    } catch (error) {
      console.warn('Web Share API failed, falling back to download:', error);
    }
  }
  
  // Fallback to download
  downloadPDF(blob, filename);
  return false;
};